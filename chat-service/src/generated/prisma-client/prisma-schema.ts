// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateMessage {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateRoomUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar Long

type Message {
  id: ID!
  content: String!
  authorId: ID!
  room: Room!
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]!
  aggregate: AggregateMessage!
}

input MessageCreateInput {
  id: ID
  content: String!
  authorId: ID!
  room: RoomCreateOneWithoutMessagesInput!
}

input MessageCreateManyWithoutRoomInput {
  create: [MessageCreateWithoutRoomInput!]
  connect: [MessageWhereUniqueInput!]
}

input MessageCreateWithoutRoomInput {
  id: ID
  content: String!
  authorId: ID!
}

type MessageEdge {
  node: Message!
  cursor: String!
}

enum MessageOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  authorId_ASC
  authorId_DESC
}

type MessagePreviousValues {
  id: ID!
  content: String!
  authorId: ID!
}

input MessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  authorId: ID
  authorId_not: ID
  authorId_in: [ID!]
  authorId_not_in: [ID!]
  authorId_lt: ID
  authorId_lte: ID
  authorId_gt: ID
  authorId_gte: ID
  authorId_contains: ID
  authorId_not_contains: ID
  authorId_starts_with: ID
  authorId_not_starts_with: ID
  authorId_ends_with: ID
  authorId_not_ends_with: ID
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
}

type MessageSubscriptionPayload {
  mutation: MutationType!
  node: Message
  updatedFields: [String!]
  previousValues: MessagePreviousValues
}

input MessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageWhereInput
  AND: [MessageSubscriptionWhereInput!]
  OR: [MessageSubscriptionWhereInput!]
  NOT: [MessageSubscriptionWhereInput!]
}

input MessageUpdateInput {
  content: String
  authorId: ID
  room: RoomUpdateOneRequiredWithoutMessagesInput
}

input MessageUpdateManyDataInput {
  content: String
  authorId: ID
}

input MessageUpdateManyMutationInput {
  content: String
  authorId: ID
}

input MessageUpdateManyWithoutRoomInput {
  create: [MessageCreateWithoutRoomInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutRoomInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutRoomInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyDataInput!
}

input MessageUpdateWithoutRoomDataInput {
  content: String
  authorId: ID
}

input MessageUpdateWithWhereUniqueWithoutRoomInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateWithoutRoomDataInput!
}

input MessageUpsertWithWhereUniqueWithoutRoomInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateWithoutRoomDataInput!
  create: MessageCreateWithoutRoomInput!
}

input MessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  authorId: ID
  authorId_not: ID
  authorId_in: [ID!]
  authorId_not_in: [ID!]
  authorId_lt: ID
  authorId_lte: ID
  authorId_gt: ID
  authorId_gte: ID
  authorId_contains: ID
  authorId_not_contains: ID
  authorId_starts_with: ID
  authorId_not_starts_with: ID
  authorId_ends_with: ID
  authorId_not_ends_with: ID
  room: RoomWhereInput
  AND: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
}

input MessageWhereUniqueInput {
  id: ID
}

type Mutation {
  createMessage(data: MessageCreateInput!): Message!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateManyMessages(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): BatchPayload!
  upsertMessage(where: MessageWhereUniqueInput!, create: MessageCreateInput!, update: MessageUpdateInput!): Message!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteManyMessages(where: MessageWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createRoomUser(data: RoomUserCreateInput!): RoomUser!
  updateRoomUser(data: RoomUserUpdateInput!, where: RoomUserWhereUniqueInput!): RoomUser
  updateManyRoomUsers(data: RoomUserUpdateManyMutationInput!, where: RoomUserWhereInput): BatchPayload!
  upsertRoomUser(where: RoomUserWhereUniqueInput!, create: RoomUserCreateInput!, update: RoomUserUpdateInput!): RoomUser!
  deleteRoomUser(where: RoomUserWhereUniqueInput!): RoomUser
  deleteManyRoomUsers(where: RoomUserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  message(where: MessageWhereUniqueInput!): Message
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message]!
  messagesConnection(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  roomUser(where: RoomUserWhereUniqueInput!): RoomUser
  roomUsers(where: RoomUserWhereInput, orderBy: RoomUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RoomUser]!
  roomUsersConnection(where: RoomUserWhereInput, orderBy: RoomUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomUserConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  name: String!
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
  users(where: RoomUserWhereInput, orderBy: RoomUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RoomUser!]
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  name: String!
  messages: MessageCreateManyWithoutRoomInput
  users: RoomUserCreateManyWithoutRoomInput
}

input RoomCreateOneWithoutMessagesInput {
  create: RoomCreateWithoutMessagesInput
  connect: RoomWhereUniqueInput
}

input RoomCreateOneWithoutUsersInput {
  create: RoomCreateWithoutUsersInput
  connect: RoomWhereUniqueInput
}

input RoomCreateWithoutMessagesInput {
  id: ID
  name: String!
  users: RoomUserCreateManyWithoutRoomInput
}

input RoomCreateWithoutUsersInput {
  id: ID
  name: String!
  messages: MessageCreateManyWithoutRoomInput
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type RoomPreviousValues {
  id: ID!
  name: String!
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateInput {
  name: String
  messages: MessageUpdateManyWithoutRoomInput
  users: RoomUserUpdateManyWithoutRoomInput
}

input RoomUpdateManyMutationInput {
  name: String
}

input RoomUpdateOneRequiredWithoutMessagesInput {
  create: RoomCreateWithoutMessagesInput
  update: RoomUpdateWithoutMessagesDataInput
  upsert: RoomUpsertWithoutMessagesInput
  connect: RoomWhereUniqueInput
}

input RoomUpdateOneRequiredWithoutUsersInput {
  create: RoomCreateWithoutUsersInput
  update: RoomUpdateWithoutUsersDataInput
  upsert: RoomUpsertWithoutUsersInput
  connect: RoomWhereUniqueInput
}

input RoomUpdateWithoutMessagesDataInput {
  name: String
  users: RoomUserUpdateManyWithoutRoomInput
}

input RoomUpdateWithoutUsersDataInput {
  name: String
  messages: MessageUpdateManyWithoutRoomInput
}

input RoomUpsertWithoutMessagesInput {
  update: RoomUpdateWithoutMessagesDataInput!
  create: RoomCreateWithoutMessagesInput!
}

input RoomUpsertWithoutUsersInput {
  update: RoomUpdateWithoutUsersDataInput!
  create: RoomCreateWithoutUsersInput!
}

type RoomUser {
  id: ID!
  userId: ID!
  room: Room!
  isAdmin: Boolean!
}

type RoomUserConnection {
  pageInfo: PageInfo!
  edges: [RoomUserEdge]!
  aggregate: AggregateRoomUser!
}

input RoomUserCreateInput {
  id: ID
  userId: ID!
  room: RoomCreateOneWithoutUsersInput!
  isAdmin: Boolean
}

input RoomUserCreateManyWithoutRoomInput {
  create: [RoomUserCreateWithoutRoomInput!]
  connect: [RoomUserWhereUniqueInput!]
}

input RoomUserCreateWithoutRoomInput {
  id: ID
  userId: ID!
  isAdmin: Boolean
}

type RoomUserEdge {
  node: RoomUser!
  cursor: String!
}

enum RoomUserOrderByInput {
  id_ASC
  id_DESC
  userId_ASC
  userId_DESC
  isAdmin_ASC
  isAdmin_DESC
}

type RoomUserPreviousValues {
  id: ID!
  userId: ID!
  isAdmin: Boolean!
}

input RoomUserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userId: ID
  userId_not: ID
  userId_in: [ID!]
  userId_not_in: [ID!]
  userId_lt: ID
  userId_lte: ID
  userId_gt: ID
  userId_gte: ID
  userId_contains: ID
  userId_not_contains: ID
  userId_starts_with: ID
  userId_not_starts_with: ID
  userId_ends_with: ID
  userId_not_ends_with: ID
  isAdmin: Boolean
  isAdmin_not: Boolean
  AND: [RoomUserScalarWhereInput!]
  OR: [RoomUserScalarWhereInput!]
  NOT: [RoomUserScalarWhereInput!]
}

type RoomUserSubscriptionPayload {
  mutation: MutationType!
  node: RoomUser
  updatedFields: [String!]
  previousValues: RoomUserPreviousValues
}

input RoomUserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomUserWhereInput
  AND: [RoomUserSubscriptionWhereInput!]
  OR: [RoomUserSubscriptionWhereInput!]
  NOT: [RoomUserSubscriptionWhereInput!]
}

input RoomUserUpdateInput {
  userId: ID
  room: RoomUpdateOneRequiredWithoutUsersInput
  isAdmin: Boolean
}

input RoomUserUpdateManyDataInput {
  userId: ID
  isAdmin: Boolean
}

input RoomUserUpdateManyMutationInput {
  userId: ID
  isAdmin: Boolean
}

input RoomUserUpdateManyWithoutRoomInput {
  create: [RoomUserCreateWithoutRoomInput!]
  delete: [RoomUserWhereUniqueInput!]
  connect: [RoomUserWhereUniqueInput!]
  set: [RoomUserWhereUniqueInput!]
  disconnect: [RoomUserWhereUniqueInput!]
  update: [RoomUserUpdateWithWhereUniqueWithoutRoomInput!]
  upsert: [RoomUserUpsertWithWhereUniqueWithoutRoomInput!]
  deleteMany: [RoomUserScalarWhereInput!]
  updateMany: [RoomUserUpdateManyWithWhereNestedInput!]
}

input RoomUserUpdateManyWithWhereNestedInput {
  where: RoomUserScalarWhereInput!
  data: RoomUserUpdateManyDataInput!
}

input RoomUserUpdateWithoutRoomDataInput {
  userId: ID
  isAdmin: Boolean
}

input RoomUserUpdateWithWhereUniqueWithoutRoomInput {
  where: RoomUserWhereUniqueInput!
  data: RoomUserUpdateWithoutRoomDataInput!
}

input RoomUserUpsertWithWhereUniqueWithoutRoomInput {
  where: RoomUserWhereUniqueInput!
  update: RoomUserUpdateWithoutRoomDataInput!
  create: RoomUserCreateWithoutRoomInput!
}

input RoomUserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userId: ID
  userId_not: ID
  userId_in: [ID!]
  userId_not_in: [ID!]
  userId_lt: ID
  userId_lte: ID
  userId_gt: ID
  userId_gte: ID
  userId_contains: ID
  userId_not_contains: ID
  userId_starts_with: ID
  userId_not_starts_with: ID
  userId_ends_with: ID
  userId_not_ends_with: ID
  room: RoomWhereInput
  isAdmin: Boolean
  isAdmin_not: Boolean
  AND: [RoomUserWhereInput!]
  OR: [RoomUserWhereInput!]
  NOT: [RoomUserWhereInput!]
}

input RoomUserWhereUniqueInput {
  id: ID
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  messages_every: MessageWhereInput
  messages_some: MessageWhereInput
  messages_none: MessageWhereInput
  users_every: RoomUserWhereInput
  users_some: RoomUserWhereInput
  users_none: RoomUserWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type Subscription {
  message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  roomUser(where: RoomUserSubscriptionWhereInput): RoomUserSubscriptionPayload
}
`